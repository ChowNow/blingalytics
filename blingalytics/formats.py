"""
Formats define how Python values in a report should be output for display or
storage.

By default, formats can provide two kinds of output, HTML and CSV, but there's
no reason more output formats couldn't be implemented.

All formats should derive from the Format class.
"""

import json
import locale

from blingalytics.utils import epoch


class Format(object):
    """
    Base class for formats.
    
    * label: A string that will be used as the label for the column. Optional,
      and if left as None a label will be automatically generated by the
      report's init method based on the format's column's name.
    * align: Either 'left' or 'right', used to determine the alignment of the
      output column. Optional, and each format type has its own default
      alignment. Generally, number-type columns default to right-aligned, and
      all other columns default to left-aligned.
    
    Subclasses should implement their own format methods. The format method
    is used as the default value formatter. You can also define as many
    format_OUTPUT methods as you like, where OUTPUT is the output type, such
    as 'html' or 'csv'. These methods are used if the formatted output varies
    between output types. The format methods should all handle a value of None
    and output an appropriate "blank" representation.
    
    Subclasses should also override the default_align and sort_alpha
    attributes, if appropriate. The default_align attribute should be either
    'left' or 'right' and determines whether, by default, the columns should
    be right-aligned or left-aligned.
    
    The sort_alpha attribute should be either True or False, and determines
    whether Redis will use alpha or numeric sorting for this column. See the
    util.cached_table module for more details.
    
    Subclasses may also override the header_info property, if appropriate.
    The report returns these property dicts as part of the table header
    information, and by default they contain column metadata for the column's
    label, alignment, hidden state and sortability.
    """
    default_align = 'left'
    sort_alpha = False

    def __init__(self, label=None, align=None):
        self.label = label
        self.align = align or self.default_align

    @property
    def header_info(self):
        info = {
            'label': self.label,
            'sortable': True,
            'data_type': self.__class__.__name__.lower(),
        }
        if self.align == 'right':
            info['className'] = 'num'
        return info

    def format(self, value):
        """Default format method simply stringifies the value."""
        if isinstance(value, basestring):
            return value.encode('utf-8')
        return str(value)

    def format_html(self, value):
        """
        By default, the HTML format method simply calls the format's basic
        format method. So if a format requires no HTML-specific formatting, it
        doesn't need to override this method.
        """
        return self.format(value)

    def format_csv(self, value):
        """
        By default, the CSV format method simply calls the format's basic
        format method. So if a format requires no CSV-specific formatting, it
        doesn't need to override this method.
        """
        return self.format(value)

    def format_raw(self, value):
        """
        Does no formatting whatsoever, and returns the Python value.
        """
        return value

class Hidden(Format):
    """
    Hidden column.
    
    This column will be marked as hidden in the header_info, so the frontend
    should not display this column in the table. The data will, however, still
    be returned as usual in case it is needed for some other function.
    """
    @property
    def header_info(self):
        info = super(Hidden, self).header_info
        info['hidden'] = True
        return info

class Bling(Format):
    """
    Monetary data column.
    
    This is formatted as currency according to the locale setting. If being
    output for HTML, it will add grouping indicators such as commas; if being
    output for CSV, it will not. By default, it is right-aligned.
    
    For example, in the en_US locale, numbers will be formatted as '$1,234.56'
    for HTML or '$1234.56' for CSV.
    """
    default_align = 'right'

    def format_html(self, value):
        if value is None:
            value = 0
        return locale.currency(value, grouping=True)

    def format_csv(self, value):
        if value is None:
            value = 0
        return locale.currency(value)

    def format_xls(self, value):
        if value is None:
            value = 0
        return value

class Epoch(Format):
    """
    Column for date data stored as number of days since the UNIX epoch.
    
    This is formatted as a date according to the locale setting. The input
    value is expected as the number of full days since the UNIX epoch
    (Jan. 1, 1970). By default, it is left-aligned.

    For example, in the en_US locale, a date is formatted as '01/23/2011'.
    """
    def format(self, value):
        if value is None:
            return ''
        return epoch.hours_to_datetime(int(value) * 24).strftime(
            locale.nl_langinfo(locale.D_FMT))

class Date(Format):
    """
    Column for date data stored as a datetime object.
    
    This is formatted as a date according to the locale setting. The input
    value is expected as a Python date or datetime instance. By default, it is
    left-aligned.

    For example, in the en_US locale, a date is formatted as '01/23/2011'.
    """
    sort_alpha = True

    def format(self, value):
        if value is None:
            return ''
        return value.strftime(locale.nl_langinfo(locale.D_FMT))

class Month(Format):
    """
    Column for date data stored as a datetime object.

    For example, date formatted as '01/23/2011' shows up as 'Jan 2011'.
    """
    sort_alpha = True

    def format(self, value):
        if value is None:
            return ''
        return value.strftime("%b %Y")

class Integer(Format):
    """
    Integer data column.
    
    * grouping: Whether or not the formatted value should have groupings, such
      as the comma separator, when output for HTML. Defaults to True.
    
    This is formatted as an integer according to the locale setting. By
    default, it is right-aligned. For example, in the en_US locale, numbers
    will be formatted as '1,234' for HTML or '1234' for CSV.
    """
    default_align = 'right'

    def __init__(self, grouping=True, **kwargs):
        self.grouping = grouping
        super(Integer, self).__init__(**kwargs)

    def format_html(self, value):
        if value is None:
            value = 0
        try:
            return locale.format('%d', value, grouping=self.grouping)
        except TypeError:
            raise TypeError('Value was not an integer: %r' % value)

    def format_csv(self, value):
        if value is None:
            value = 0
        try:
            return locale.format('%d', value)
        except TypeError:
            raise TypeError('Value was not an integer: %r' % value)

    def format_xls(self, value):
        if value is None:
            value = 0
        if self.grouping:
            return value
        return str(value)

class Percent(Format):
    """
    Percent data column.
    
    * precision: The number of decimal places of precision that should be
      kept for display. Defaults to 1.
    
    This is formatted as a decimal number with a trailing percent sign. By
    default, it is right-aligned. For example, numbers will be formatted as
    '12.3%' with a precision of 1.
    """
    default_align = 'right'

    def __init__(self, precision=1, **kwargs):
        self.precision = precision
        super(Percent, self).__init__(**kwargs)

    def format(self, value):
        if value is None:
            value = 0
        return locale.format('%%.%df' % self.precision, value) + '%'

    def format_xls(self, value):
        if value is None:
            value = 0
        return value / 100

class String(Format):
    """
    String data column.
    
    * title: If True, will title-case the string. Defaults to False.
    * truncate: If set, truncates the string to this number of characters and
      adds an ellipsis. Defaults to None.
    
    This is basic string formatter. It is left-aligned by default.
    """
    sort_alpha = True

    def __init__(self, title=False, truncate=None, **kwargs):
        self.title = title
        self.truncate = truncate
        super(String, self).__init__(**kwargs)

    def format(self, value):
        if value is None:
            return ''
        if isinstance(value, basestring):
            value = value.encode('utf-8')
        else:
            value = str(value)
        if self.truncate is not None:
            if len(value) > self.truncate:
                value = value[:self.truncate - 3] + '...'
        if self.title:
            value = value.title()
        return value

class Boolean(Format):
    """
    Boolean data column.
    
    * terms: This is a tuple of three strings, provided the formatted output
      for True, False, and None, in that order. Defaults to ('Yes', 'No', '').
    
    This column is left-aligned by default.
    """
    def __init__(self, terms=('Yes', 'No', ''), **kwargs):
        self.true_term, self.false_term, self.none_term = terms
        super(Boolean, self).__init__(**kwargs)

    def format(self, value):
        if value is None:
            return self.none_term
        elif value:
            return self.true_term
        return self.false_term

class JSON(Format):
    """
    Arbitrary Python data, formatted as JSON.
    
    This simply runs json.dumps on the data, so you must ensure that it is
    JSON-encodable or you'll get a ValueError. This column is left-aligned by
    default.
    """
    def format(self, value):
        return json.dumps(value)
